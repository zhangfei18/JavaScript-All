# SSR 服务端渲染 nuxt.js/ next.js

1.利于 SEO  
2.服务器骨架屏技术， 服务器给力的话打开速度很快

# 前后端分离：

先拿到 html 空架子，再用 js 获取数据，最后再放到 html 上进行渲染
web 服务器
数据服务器
跨域问题也就出来了

# 编码

(前后端都有)
编译中文字符
encodeURI
decodeURI
编译特殊字符
encodeURIComponent
decodeURIComponent

(只有前端有)：适合用于本地存储的 cookie、localStorage
编译特殊字符和汉字
escape
unescape

# 强缓存（都是对资源问价你的缓存，不是对数据的缓存）

位置：
内存缓存 Memory Cache
硬盘缓存 Disk Cache
打开网页：查找硬盘缓存
普通刷新：【F5】 Memory Cache Disk Cache
强制刷新：【Ctrl + F5】 重新请求数据 请求头均带有 Cache-control: no-cache

强缓存：
Expires: Sat, 30 Jan 2021 02:53:23 GMT http 1.0 使用
Cache-Control: max-age=14440 htttp 1.1
服务器设置的，并且基于响应头信息返回给客户端你的（ngnix 这些发包工具搞定的）；客户端浏览器接受到响应后， 会自己建立缓存机制

第一次请求：无缓存， 直接请求 状态码返回 200
第二次请求： 检查本地缓存是否过期，过期直接请求，无过期直接返回

强缓存存在的问题：
客户端由于在缓存时间内走了缓存，但是服务器上的文件已经更新了，这样就会使用户访问的时候还是看到的旧的页面
解决办法：
前提：html 页面文件是不进行缓存的，
css/ js / png...可以强缓存，这样才能保证每次的 html 文件都是从服务器拿的最新的
处理：
html 文件中导入的路径后面加上时间戳
资源文件的名字在内容发生更改后，名字会重新更新 hash 值，这个可以使用 webpack 来搞，
这样每次都是会从服务器请求 HTML 文件的，但是由于加了时间戳或者哈希值，因此只要服务器上的文件被更新了，都会请求新的资源过来。

# 协商缓存(没有强缓存或者强缓存失效走 协商缓存)

Last-Modified / If-Modified-Since: http 1.0
Etag / If-None-Match http 1.1
第一次请求没有任何缓存， 直接从服务器获取资源和标识 Last-Modified / ETag , 状态码返回 200
第二次请求，检测本地是否有存储的标识， 如果没有认为没有缓存， 重复上一个步骤， 如果有：
基于标识 「If-Modified-Since/If-None-Match」为 key, 把之前存储的 Last-Modified / ETag 结果为值传递给服务器，
到达服务器后，（由于之前在项目文件部署的时候，会生成 Last-Modified / ETag 对应的值， 这个值代表当前项目文件在服务器上最后一次更新的时间或者对应的标识）接受到客户端的请求后，和之前的存储的值进行比较，
如果一致，则说明文件没有更新，直接返回 状态码 304,
如果不一致，返回最新的项目文件给客户端.
客户端收到响应，判断状态码，
304 把之前的文件拿出来渲染
200 按照最新的文件渲染， 同时更新本地的缓存

所以 html 文件完全可以设置协商缓存， 其他的文件同时设置两种缓存

# 数据缓存--->不经常更新的数据

    ajax axios
    fetch

    方案：
        A.本地存储： cookie/localStorage/sessionStorage
        B.本地数据库存储： IndexDB
        C.vuex/redux...

    实现步骤：
    1.第一次发送数据请求，本地没有任何的缓存（或者缓存周期已经过了），基于ajax拿取数据
    2.在进行数据绑定的时候，同时把获取的数据存储到本地「存储的时候我们一般会自己手动设置过期时间」
    3.再次发送请求（例如重新打开页面、刷新页面。。。）我么你依然是查找本地缓存是否已过期，如果未失效，直接使用缓存的数据，反之，重复执行1、2步。

    使用：
    如果需要存储的数据量特别大，则基于IndexDB是一个不错的选择（localStorage 一个源下只能存储5M）
    A和B 都是把信息存储到物理磁盘上， 哪怕页面关闭都不会消失。（除sessionStorage，关闭页面会消失）
    localStorage 本地存储
    sessionStorage 会话存储
    cookie存储的内容会自动发送到服务器
        只读： httponly
    C 类似于定义了全局变量，页面关闭直接消失， 在SPA单页面应用，组件之间来回切换的时候可以使用

# DNS 解析

20~120ms
递归查询
客户端->浏览器缓存->本地 hosts 文件->本地 DNS 解析器缓存->本地 DNS 服务器
迭代查询

优化：
· 一个产品尽可能少去请求服务器/域名（减少 DNS 的解析次数）被舍弃的方案
· DNS 预解析 <link rel="dns-prefetch" href=""> 「利用 link 标签的异步性」
当代产品的开发，资源一般都是部署到不同的服务器上「尤其是大型项目」
web 资源服务器 ngnix/apache/iis 「html/css/js」
图片资源服务器 「图片...」
数据服务器「后台程序、数据库...」
第三方服务器
弊端：增加了 dns 解析的时间
优势：
合理的服务器资源分配 & 提高并发 「每一台服务器的并发都是有上限的」
每一个源下，可以同时允许的 HTTP 并发数为 6-7 个，有助于页面的渲染速度的。

建立传输通道：网络进程

# TCP 三次握手、四次挥手

长连接 Connection: keep-alive

渲染进程开始准备请求头，基于 HTTP 发送请求->解析响应头->「重定向重新请求新的服务器」->

# 数据传输

    减少数据传输的大小：
        文件压缩
        服务端开启gzip压缩
        分页处理
    减少HTTP请求次数
        资源文件合并
        base64
    CDN服务器：地域式分布 ：由总服务器分发到各地的服务器上

# HTTP
